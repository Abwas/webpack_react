<html><head><title>From Notes to Kanban / SurviveJS - Survive the jungles of JavaScript</title><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimal-ui"><link rel="icon" type="image/png" href="/assets/img/favicon.png"><link rel="stylesheet" href="/assets/main.css"></head><body><div><div class="nav__wrapper"><input type="checkbox" class="nav__toggle" id="nav__toggle"><label class="nav__toggle-label" for="nav__toggle"></label><nav class="nav"><a class="nav__link" href="/">Home</a><a class="nav__link" href="/webpack_react">Table of Contents</a></nav></div><main role="main"><div class="post"><h1 class="post__heading">From Notes to Kanban</h1><div class="post__content"><div><p><img src="/images/kanban.png" alt="Kanban board"></p>
<p>So far our Notes Application is very simplistic. We can manipulate the Note items. There is also a basic level of persistency. We are still missing some vital functionality that is needed to turn it this into a proper Kanban table (see image above).</p>
<p>Most importantly we&apos;ll need to model the concept of lane. A lane is something that contains a name and some note items. If we model these requirements as a data structure, we&apos;ll end up with something like this:</p>
<pre><code class="language-javascript">{
  lanes: [
    {
      name: &apos;Todo&apos;,
      notes: [
        {
          task: &apos;Learn Webpack&apos;
        },
        {
          task: &apos;Do laundry&apos;
        }
      ]
    },
    {
      name: &apos;Doing&apos;,
      notes: [
        {
          task: &apos;Learn React&apos;
        }
      ]
    },
    {
      name: &apos;Done&apos;,
      notes: []
    }
  ]
}
</code></pre>
<p>The question is how do we map this structure to our React app. We could try to define a <code>AppStore</code> to manage the highest level of hierarchy. Ideally this would be something we could just serialize for persistency. Lower in the hierarchy there would perhaps be <code>LaneStore</code> and <code>NoteStore</code> for managing these particular structures. In addition we would have Actions for each. We would have to keep <code>AppStore</code> synced up somehow for serialization to work.</p>
<p>As you can see this approach would get complex quite fast. Once you have some form of duplication in your application and need to think about syncing, you&apos;ll open a lot of possibilities for bugs. Clearly Flux, as discussed in the previous chapter, isn&apos;t the tool we want to apply here.</p>
<h2>Introduction to Baobab</h2>
<p>Wouldn&apos;t it be useful if we could operate on the data structure we just defined and give our components views to it based on their requirements? If some part of the structure changed, we would still have something consistent on the highest level on the hierarchy.</p>
<p><a href="https://github.com/Yomguithereal/baobab">baobab</a> is a JavaScript data tree library that allows us to do this. Consider the following demo:</p>
<pre><code class="language-javascript"><span class="hljs-keyword">var</span> Baobab = <span class="hljs-built_in">require</span>(&apos;baobab&apos;);

<span class="hljs-keyword">var</span> tree = <span class="hljs-keyword">new</span> Baobab({
  lanes: [
    {
      name: &apos;demo&apos;,
      notes: [
        {
          task: &apos;foo&apos;,
        }
      ]
    }
  ],
});

<span class="hljs-keyword">var</span> rootCursor = tree.root;
<span class="hljs-keyword">var</span> laneCursor = tree.select(&apos;lanes&apos;, <span class="hljs-number">0</span>);
<span class="hljs-keyword">var</span> noteCursor = laneCursor.select(&apos;notes&apos;);

rootCursor.on(&apos;update&apos;, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(
    &apos;updated root&apos;,
    <span class="hljs-built_in">JSON</span>.stringify(rootCursor.get(), <span class="hljs-literal">null</span>, <span class="hljs-number">2</span>)
  );
});

laneCursor.on(&apos;update&apos;, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(&apos;updated lane&apos;, laneCursor.get());
});

noteCursor.push({task: &apos;Demo task&apos;});
</code></pre>
<p>If you run the code, you should see output like this:</p>
<pre><code class="language-javascript">updated root {
  &quot;lanes&quot;: [
    {
      &quot;name&quot;: &quot;demo&quot;,
      &quot;notes&quot;: [
        {
          &quot;task&quot;: &quot;foo&quot;
        },
        {
          &quot;task&quot;: &quot;Demo task&quot;
        }
      ]
    }
  ]
}
updated lane { name: &apos;demo&apos;,
  notes: [ { task: &apos;foo&apos; }, { task: &apos;Demo task&apos; } ] }
</code></pre>
<p>Imagine the same in the context of React. We could model a small API for operations and a cursor per component. On the high level we would have the data we need without having to think about syncing. The data structure takes care of it for you.</p>
<p>A baobab tree can keep track of it changes. In naive cases, such as ours, this can give us an undo system pretty much for free. We will just need to activate the functionality and hook up the underlying API with our application.</p>
<p>T&gt; Note that we will need to operate through baobab&apos;s API. It will apply changes asynchronously by default. If you need something synchronous, you&apos;ll need to hit <code>tree.commit()</code> after an operation to force instant refresh.</p>
<h2>Gluing Baobab with React</h2>
<blockquote>
<p>XXXXX: Danger Will Robinson. This part is under progress!</p>
</blockquote>
<p>Hit <code>npm i baobab baobab-react typology --save</code> to include baobab in the project. You can also remove <code>alt</code> dependency from the project by editing <em>package.json</em>. Here is what possible integration could look like:</p>
<p><strong>app/components/App.jsx</strong></p>
<pre><code class="language-javascript">import React from &apos;react&apos;;
import {root} from &apos;baobab-react/decorators&apos;;
import Lanes from &apos;./Lanes&apos;;
import storage from &apos;../libs/storage&apos;;
import laneActions from &apos;../actions/LaneActions&apos;;
import tree from &apos;./tree&apos;;

@root(tree)
<span class="hljs-built_in">export</span> default class App extends React.Component {
  constructor(props) {
    super(props);

    this.laneActions = laneActions(tree.select(&apos;lanes&apos;));
  }
  <span class="hljs-function"><span class="hljs-title">render</span></span>() {
    <span class="hljs-built_in">return</span> (
      <div classname="app">
        <div classname="controls">
          <button onclick="{this.laneActions.create.bind(null," 'new="" lane')}="">
            Add lane
          </button>
        </div>
        <lanes>
      </lanes></div>
    );
  }
}
</code></pre>
<p><strong>app/components/Tree.js</strong></p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> Baobab <span class="hljs-keyword">from</span> &apos;baobab&apos;;
<span class="hljs-keyword">import</span> types <span class="hljs-keyword">from</span> &apos;typology&apos;;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> Baobab({
    lanes: []
  }, {
    validate: (previousState, newState, affectedPaths) =&gt; {
      <span class="hljs-keyword">const</span> schema = {
        lanes: [{
          id: &apos;number&apos;,
          name: &apos;string&apos;,
          notes: [
            {
              id: &apos;number&apos;,
              task: &apos;string&apos;,
            }
          ]
        }]
      };
      <span class="hljs-keyword">const</span> valid = types.check(schema, newState);

      <span class="hljs-keyword">if</span>(!valid) {
        <span class="hljs-keyword">const</span> err = types.scan(schema, newState);

        <span class="hljs-built_in">console</span>.error(err);

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(err.error);
      }
    }
  }
);
</code></pre>
<p>It takes a little extra effort to validate the contents of our tree but it&apos;s worth it. We can now be sure that the tree always contains the data we expect. The validation logic could be extracted and made reusable but this will just fine for our purposes.</p>
<h2>Modeling <code>LaneActions</code></h2>
<p>We get a reference to the tree root at this level. For now it&apos;s enough if we can create new lanes. Besides a name we&apos;ll attach an id to each lane based on their amount. Ids will come in handy later as we implement drag and drop.</p>
<p><strong>app/actions/LaneActions.js</strong></p>
<pre><code class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> (cursor) =&gt; {
  <span class="hljs-keyword">return</span> {
    create: (name) =&gt; {
      cursor.push({
        id: lanes.get().length,
        name: name,
        notes: []
      });
    }
  };
};
</code></pre>
<p>Note how we are keeping things simple and skipping dispatching, Stores and all that. The tree deals with updates for us.</p>
<h2>Modeling Lanes</h2>
<p>To follow the same ideas as before I&apos;ve split up Lanes into two concepts. Into a container and an individual.</p>
<p><strong>app/components/Lanes.jsx</strong></p>
<pre><code class="language-javascript">import React from &apos;react&apos;;
import Lane from &apos;./Lane&apos;;
import {branch} from &apos;baobab-react/decorators&apos;;

@branch({
  cursors: {
    lanes: [&apos;lanes&apos;]
  }
})
<span class="hljs-built_in">export</span> default class Lanes extends React.Component {
  <span class="hljs-function"><span class="hljs-title">render</span></span>() {
    var lanes = this.props.lanes;

    <span class="hljs-built_in">return</span> (
      <div classname="lanes">
        {lanes.map((lane, i) =&gt;
          <lane key="{&apos;lane&apos;" +="" i}="" lanecursor="{[&apos;lanes&apos;," i]}="">
        )}
      </lane></div>
    );
  }
}
</code></pre>
<p>The lanes operate within a specific part of the tree. I use <code>@branch</code> decorator for defining this binding. We use the same idea with <code>Lane</code>. In addition we pass a part of the cursor we need to a <code>Lane</code> as we want to restrict it to a specific index.</p>
<p><strong>app/components/Lane.jsx</strong></p>
<pre><code class="language-javascript">import React from &apos;react&apos;;
import {branch} from &apos;baobab-react/decorators&apos;;
import PropTypes from &apos;baobab-react/prop-types&apos;;
import Notes from &apos;./Notes&apos;;
import noteActions from &apos;../actions/NoteActions&apos;;

@branch({
  cursors: <span class="hljs-keyword">function</span>(props) {
    <span class="hljs-built_in">return</span> {
      lane: props.laneCursor
    };
  }
})
<span class="hljs-built_in">export</span> default class Lane extends React.Component {
  static contextTypes = {
    cursors: PropTypes.cursors
  }
  constructor(props: {
    laneCursor: Array;
  }, context) {
    super(props);

    this.laneActions = noteActions(context.cursors.lane.select(&apos;notes&apos;));
  }
  <span class="hljs-function"><span class="hljs-title">render</span></span>() {
    var laneCursor = this.props.laneCursor;
    var lane = this.props.lane;

    <span class="hljs-built_in">return</span> (
      <div classname="lane">
        <div classname="lane-header">
          <div classname="lane-name">{lane.name}</div>
          <div classname="lane-controls">
            <button classname="lane-add-note" onclick="{this.laneActions.create.bind(null," 'new="" task')}="">+</button>
          </div>
        </div>
        <notes notescursor="{laneCursor.concat([&apos;notes&apos;])}">
      </notes></div>
    );
  }
}
</code></pre>
<p>Note that <code>Lane</code> deals with <code>add</code> now for clarity.</p>
<h2>Altering <code>Notes</code></h2>
<p>As there are plenty of changes in <code>Notes</code>, I&apos;ll show it in its entirety.</p>
<p><strong>app/components/Notes.jsx</strong></p>
<pre><code class="language-javascript">import React from &apos;react&apos;;
import {branch} from &apos;baobab-react/decorators&apos;;
import PropTypes from &apos;baobab-react/prop-types&apos;;
import Note from &apos;./Note&apos;;
import noteActions from &apos;../actions/NoteActions&apos;;

@branch({
  cursors: <span class="hljs-keyword">function</span>(props) {
    <span class="hljs-built_in">return</span> {
      notes: props.notesCursor
    };
  }
})
<span class="hljs-built_in">export</span> default class Notes extends React.Component {
  static contextTypes = {
    cursors: PropTypes.cursors
  }
  constructor(props: {
    notesCursor: Array;
  }, context) {
    super(props);

    this.actions = noteActions(context.cursors.notes);
  }
  render(props, context) {
    var notes = this.props.notes;

    <span class="hljs-built_in">return</span> (
      <ul classname="notes">{notes.map((note, i) =&gt;
        <li key="{&apos;note&apos;" +="" i}="">
          <note task="{note.task}" onedit="{this.itemEdited.bind(this," i)}="">
        </note></li>
      )}</ul>
    );
  }
  itemEdited(id, task) {
    <span class="hljs-keyword">if</span>(task) {
      this.actions.update(id, task);
    }
    <span class="hljs-keyword">else</span> {
      this.actions.remove(id);
    }
  }
}
</code></pre>
<p>The most important change has to do with the way we deal with Actions. Just like with <code>LaneActions</code>, <code>NoteActions</code> is as light as possible. It operates using the cursor directly as below:</p>
<p><strong>app/actions/NoteActions.jsx</strong></p>
<pre><code class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> (cursor) =&gt; {
  <span class="hljs-keyword">return</span> {
    create: (task) =&gt; {
      <span class="hljs-keyword">const</span> id = cursor.get().length || <span class="hljs-number">0</span>;

      cursor.push({id, task});
    },
    update: (i, task) =&gt; {
      cursor.select(i).update({
        task: {
          $set: task
        }
      });
    },
    remove: (i) =&gt; {
      cursor.unset(i);
    }
  };
};
</code></pre>
<p>The implementation of a <code>Note</code> remains the same as earlier.</p>
<h2>Persisting to a Storage</h2>
<p>As it is annoying to lose data between refreshes, we probably should restore that functionality. We can achieve that with a decorator like this:</p>
<p><strong>app/components/App.jsx</strong></p>
<pre><code class="language-javascript">...
<span class="hljs-keyword">import</span> persist <span class="hljs-keyword">from</span> &apos;../decorators/persist&apos;;
<span class="hljs-keyword">import</span> storage <span class="hljs-keyword">from</span> &apos;../libs/storage&apos;;
...

@persist(tree, storage, &apos;app&apos;)
@root(tree)
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
...
}
</code></pre>
<p><strong>app/decorators/persist.js</strong></p>
<pre><code class="language-javascript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> &apos;react&apos;;

<span class="hljs-keyword">const</span> root = (Component, tree, storage, storageName) =&gt; {
  <span class="hljs-keyword">return</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Persist</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
    constructor(props) {
      <span class="hljs-keyword">super</span>(props);

      <span class="hljs-keyword">var</span> data = storage.get(storageName);

      <span class="hljs-keyword">if</span>(data) {
        tree.set(data);
        tree.commit();
      }

      <span class="hljs-built_in">window</span>.addEventListener(&apos;beforeunload&apos;, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-comment">// escape hatch for debugging</span>
        <span class="hljs-keyword">if</span>(!storage.get(&apos;debug&apos;)) {
          storage.set(storageName, tree.get());
        }
      }, <span class="hljs-literal">false</span>);
    }
    render() {
      <span class="hljs-keyword">return</span> <component {...this.props}="" {...this.state}="">;
    }
  };
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> (tree, storage, storageName) =&gt; {
  <span class="hljs-comment">// storage expects</span>
  <span class="hljs-comment">// * get(storageName)</span>
  <span class="hljs-comment">// * set(storageName, data)</span>
  <span class="hljs-keyword">return</span> (target) =&gt; root(target, tree, storage, storageName);
};

</component></code></pre>
<p>The nice thing about our implementation is that you can apply the decorator in any part of your tree, not just the root as we are doing here. So in case you wanted to persist just certain view within a more complex application, this could do it.</p>
<h2>Removing Lanes</h2>
<p>TODO</p>
<h2>Editing Lane Name</h2>
<p>TODO</p>
<h2>Undoing and Redoing</h2>
<p>XXX: show how to implement a simple undo to the app on top of baobab</p>
<h2>Conclusion</h2>
<p>After these changes we should have something roughed together that works. It might not be the prettiest Kanban application out there and it might be missing some functionality but at least we have lanes now and can define notes within them. In the next chapter we will start polishing the application so that it actually looks good.</p>
</div></div></div><noscript></noscript><div class="prevnext-pages"><a href="/webpack_react/react_and_flux" class="previous-page">React and Flux</a><a href="/webpack_react/styling_react" class="next-page">Styling React</a></div></main></div></body></html>